/**
 * DCS MonitorSetup Service
 * Reads and writes DCS MonitorSetup.lua files for viewport configuration.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { LuaParser } from './dcsLuaParser';

export interface DCSViewport {
  name: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface DCSMonitorSetup {
  name: string;
  filePath: string;
  viewports: DCSViewport[];
  raw: string;
}

export class DCSMonitorSetupService {
  private getSavedGamesPath(): string | null {
    const candidates = [
      path.join(os.homedir(), 'Saved Games', 'DCS'),
      path.join(os.homedir(), 'Saved Games', 'DCS.openbeta'),
    ];
    for (const p of candidates) {
      if (fs.existsSync(p)) return p;
    }
    return null;
  }

  private getMonitorSetupDir(): string | null {
    const sgPath = this.getSavedGamesPath();
    if (!sgPath) return null;
    const dir = path.join(sgPath, 'Config', 'MonitorSetup');
    if (fs.existsSync(dir)) return dir;
    return null;
  }

  /**
   * List available MonitorSetup.lua files.
   */
  listMonitorSetups(): DCSMonitorSetup[] {
    const dir = this.getMonitorSetupDir();
    if (!dir) return [];

    const results: DCSMonitorSetup[] = [];
    try {
      const files = fs.readdirSync(dir).filter((f) => f.endsWith('.lua'));
      for (const file of files) {
        const filePath = path.join(dir, file);
        try {
          const raw = fs.readFileSync(filePath, 'utf-8');
          const viewports = this.parseMonitorSetup(raw);
          results.push({
            name: file.replace('.lua', ''),
            filePath,
            viewports,
            raw,
          });
        } catch (err) {
          console.error(`Failed to parse MonitorSetup ${file}:`, err);
        }
      }
    } catch (err) {
      console.error('Failed to list MonitorSetup files:', err);
    }
    return results;
  }

  /**
   * Parse a MonitorSetup.lua file and extract viewports.
   */
  parseMonitorSetup(content: string): DCSViewport[] {
    const viewports: DCSViewport[] = [];

    try {
      const parser = new LuaParser(content);
      const parsed = parser.parse();

      // MonitorSetup files define viewports in various formats
      // Common pattern: { Center = { x = 0, y = 0, width = 1920, height = 1080 } }
      this.extractViewports(parsed, viewports);
    } catch {
      // Fallback: regex-based extraction
      const vpRegex =
        /(\w+)\s*=\s*\{\s*x\s*=\s*(-?\d+)\s*,\s*y\s*=\s*(-?\d+)\s*,\s*width\s*=\s*(\d+)\s*,\s*height\s*=\s*(\d+)/g;
      let match;
      while ((match = vpRegex.exec(content)) !== null) {
        viewports.push({
          name: match[1],
          x: parseInt(match[2]),
          y: parseInt(match[3]),
          width: parseInt(match[4]),
          height: parseInt(match[5]),
        });
      }
    }

    return viewports;
  }

  private extractViewports(
    obj: Record<string, unknown>,
    viewports: DCSViewport[],
    prefix: string = ''
  ): void {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object' && value !== null) {
        const v = value as Record<string, unknown>;
        if (
          typeof v['x'] === 'number' &&
          typeof v['y'] === 'number' &&
          typeof v['width'] === 'number' &&
          typeof v['height'] === 'number'
        ) {
          viewports.push({
            name: prefix ? `${prefix}.${key}` : key,
            x: v['x'] as number,
            y: v['y'] as number,
            width: v['width'] as number,
            height: v['height'] as number,
          });
        } else {
          this.extractViewports(
            v as Record<string, unknown>,
            viewports,
            prefix ? `${prefix}.${key}` : key
          );
        }
      }
    }
  }

  /**
   * Write a MonitorSetup.lua file with the given viewports.
   */
  writeMonitorSetup(name: string, viewports: DCSViewport[]): boolean {
    const dir = this.getMonitorSetupDir();
    if (!dir) return false;

    const filePath = path.join(dir, `${name}.lua`);
    const lua = this.generateLua(viewports);

    try {
      fs.writeFileSync(filePath, lua);
      return true;
    } catch (err) {
      console.error('Failed to write MonitorSetup:', err);
      return false;
    }
  }

  private generateLua(viewports: DCSViewport[]): string {
    const lines: string[] = ['-- Generated by RigReady', ''];

    for (const vp of viewports) {
      lines.push(`${vp.name} = {`);
      lines.push(`    x = ${vp.x},`);
      lines.push(`    y = ${vp.y},`);
      lines.push(`    width = ${vp.width},`);
      lines.push(`    height = ${vp.height},`);
      lines.push(`}`);
      lines.push('');
    }

    return lines.join('\n');
  }
}

export const dcsMonitorSetupService = new DCSMonitorSetupService();
