/**
 * Unit tests for DCSMonitorSetupService
 */

import * as fs from 'fs';
import * as path from 'path';

jest.mock('fs');
jest.mock('os', () => ({
  homedir: jest.fn(() => '/mock/home'),
}));

jest.mock('../../src/main/services/dcsLuaParser', () => ({
  LuaParser: jest.fn().mockImplementation(() => ({
    parse: jest.fn(() => ({})),
  })),
}));

const mockedFs = fs as jest.Mocked<typeof fs>;

// Must import after mocks are set up
import { dcsMonitorSetupService } from '../../src/main/services/dcsMonitorSetupService';
// eslint-disable-next-line @typescript-eslint/no-require-imports
const { LuaParser: MockedLuaParser } = require('../../src/main/services/dcsLuaParser') as {
  LuaParser: jest.Mock;
};

describe('DCSMonitorSetupService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('listMonitorSetups', () => {
    it('returns empty when no DCS saved games path found', () => {
      // Neither DCS nor DCS.openbeta directories exist
      mockedFs.existsSync.mockReturnValue(false);

      const result = dcsMonitorSetupService.listMonitorSetups();

      expect(result).toEqual([]);
    });

    it('returns .lua files from MonitorSetup directory', () => {
      const dcsPath = path.join('/mock/home', 'Saved Games', 'DCS');
      const monitorSetupDir = path.join(dcsPath, 'Config', 'MonitorSetup');
      const luaFilePath = path.join(monitorSetupDir, 'triple-monitor.lua');
      const luaContent = 'Center = { x = 0, y = 0, width = 1920, height = 1080 }';

      // existsSync: first call for DCS path, second for MonitorSetup dir
      mockedFs.existsSync.mockImplementation((p: fs.PathLike) => {
        const s = p.toString();
        if (s === dcsPath) return true;
        if (s === monitorSetupDir) return true;
        return false;
      });

      (mockedFs.readdirSync as jest.Mock).mockReturnValue(['triple-monitor.lua', 'readme.txt']);
      mockedFs.readFileSync.mockReturnValue(luaContent);

      const result = dcsMonitorSetupService.listMonitorSetups();

      expect(result).toHaveLength(1);
      expect(result[0].name).toBe('triple-monitor');
      expect(result[0].filePath).toBe(luaFilePath);
      expect(result[0].raw).toBe(luaContent);
      expect(mockedFs.readdirSync).toHaveBeenCalledWith(monitorSetupDir);
    });
  });

  describe('parseMonitorSetup', () => {
    it('extracts viewports using regex fallback', () => {
      // LuaParser mock throws to trigger regex fallback
      MockedLuaParser.mockImplementation(() => ({
        parse: jest.fn(() => {
          throw new Error('parse error');
        }),
      }));

      const content = [
        'Center = { x = 0, y = 0, width = 1920, height = 1080 }',
        'Left = { x = -1920, y = 0, width = 1920, height = 1080 }',
      ].join('\n');

      const result = dcsMonitorSetupService.parseMonitorSetup(content);

      expect(result).toHaveLength(2);

      expect(result[0]).toEqual({
        name: 'Center',
        x: 0,
        y: 0,
        width: 1920,
        height: 1080,
      });

      expect(result[1]).toEqual({
        name: 'Left',
        x: -1920,
        y: 0,
        width: 1920,
        height: 1080,
      });
    });

    it('returns empty for content with no viewports', () => {
      // LuaParser returns an empty object (no viewports found)
      MockedLuaParser.mockImplementation(() => ({
        parse: jest.fn(() => ({})),
      }));

      const content = '-- Just a comment\nlocal someVar = 42\n';

      const result = dcsMonitorSetupService.parseMonitorSetup(content);

      expect(result).toEqual([]);
    });
  });

  describe('writeMonitorSetup', () => {
    it('writes valid Lua file', () => {
      const dcsPath = path.join('/mock/home', 'Saved Games', 'DCS');
      const monitorSetupDir = path.join(dcsPath, 'Config', 'MonitorSetup');

      mockedFs.existsSync.mockImplementation((p: fs.PathLike) => {
        const s = p.toString();
        if (s === dcsPath) return true;
        if (s === monitorSetupDir) return true;
        return false;
      });

      mockedFs.writeFileSync.mockImplementation(() => undefined);

      const viewports = [
        { name: 'Center', x: 0, y: 0, width: 1920, height: 1080 },
        { name: 'Left', x: -1920, y: 0, width: 1920, height: 1080 },
      ];

      const result = dcsMonitorSetupService.writeMonitorSetup('my-setup', viewports);

      expect(result).toBe(true);

      const expectedPath = path.join(monitorSetupDir, 'my-setup.lua');
      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(expectedPath, expect.any(String));

      // Verify the generated Lua content
      const writtenContent = (mockedFs.writeFileSync as jest.Mock).mock.calls[0][1] as string;
      expect(writtenContent).toContain('-- Generated by RigReady');
      expect(writtenContent).toContain('Center = {');
      expect(writtenContent).toContain('x = 0,');
      expect(writtenContent).toContain('y = 0,');
      expect(writtenContent).toContain('width = 1920,');
      expect(writtenContent).toContain('height = 1080,');
      expect(writtenContent).toContain('Left = {');
      expect(writtenContent).toContain('x = -1920,');
    });

    it('returns false when no monitor setup dir', () => {
      // No DCS paths exist
      mockedFs.existsSync.mockReturnValue(false);

      const viewports = [{ name: 'Center', x: 0, y: 0, width: 1920, height: 1080 }];

      const result = dcsMonitorSetupService.writeMonitorSetup('my-setup', viewports);

      expect(result).toBe(false);
      expect(mockedFs.writeFileSync).not.toHaveBeenCalled();
    });
  });
});
